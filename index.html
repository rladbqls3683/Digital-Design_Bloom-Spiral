<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bloom Spiral - Intro</title>
  <style>
    *{box-sizing:border-box;}
    html,body{
      margin:0;
      height:100%;
      font-family:"Helvetica Neue", Arial, sans-serif;
    }
    body{
      background:#fff;
      overflow:hidden;
      cursor:pointer;
    }
    .scene{
      position:fixed;
      inset:0;
    }
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }
    .dim{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.6);
    }
    .logo{
      position:absolute;
      top:10px;
      left:50%;
      transform:translateX(-50%);
      width:calc(100vw - 40px);
      max-width:none;
      height:auto;
      display:block;
      filter:brightness(0) invert(1) drop-shadow(0 10px 24px rgba(0,0,0,0.45));
      pointer-events:none;
    }
    .cta{
      position:absolute;
      bottom:44px;
      left:50%;
      transform:translateX(-50%);
      color:#fff;
      font-size:16px;
      font-weight:600;
      letter-spacing:0.02em;
      text-shadow:0 2px 8px rgba(0,0,0,0.4);
      pointer-events:none;
    }
    .blackout{
      position:fixed;
      inset:0;
      background:#000;
      z-index:99;
      opacity:1;
      transition:opacity 1.2s ease;
      pointer-events:auto;
    }
    .blackout.is-hidden{
      opacity:0;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="scene" id="scene">
    <canvas id="bgCanvas"></canvas>
    <div class="dim"></div>
    <img src="OPLOGO.svg" alt="Bloom Spiral" class="logo" />
    <div class="cta">Click That Bloom!</div>
  </div>
  <div class="blackout" id="blackout"></div>

  <script>
    (() => {
      const canvas = document.getElementById("bgCanvas");
      const ctx = canvas.getContext("2d");

      const COLORS = {
        line: "#325940",
        main: "#D74236",
        accent: "#A3BFAF",
        sub: "#648C72",
        light: "#F2F2F2"
      };

      const PALETTES = [
        { line: "#2E1A47", main: "#7B2CBF", accent: "#C77DFF", sub: "#48BFE3", light: "#E0D4FA" },
        { line: "#2F3E46", main: "#354F52", accent: "#84A98C", sub: "#CAD2C5", light: "#F6FFF6" },
        { line: "#3A2E39", main: "#E3427D", accent: "#F9C74F", sub: "#43AA8B", light: "#F1E9DA" },
        { line: "#3B2C30", main: "#C73E1D", accent: "#FF9F1C", sub: "#F1D302", light: "#F9F7F3" },
        { line: "#1F2A44", main: "#D00000", accent: "#FFBA08", sub: "#3F88C5", light: "#F8F9FA" }
      ];

      const CONFIG = {
        leafCount: 32,
        leafStart: 70,
        bugCount: 8
      };

      function getPalette() {
        return [COLORS.main, COLORS.accent, COLORS.sub, COLORS.light];
      }

      function hexToHsl(hex) {
        let r = 0, g = 0, b = 0;
        if (hex.length === 4) {
          r = "0x" + hex[1] + hex[1];
          g = "0x" + hex[2] + hex[2];
          b = "0x" + hex[3] + hex[3];
        } else if (hex.length === 7) {
          r = "0x" + hex[1] + hex[2];
          g = "0x" + hex[3] + hex[4];
          b = "0x" + hex[5] + hex[6];
        }
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        return { h: h * 360, s: s * 100, l: l * 100 };
      }

      function hslToHex(h, s, l) {
        h /= 360; s /= 100; l /= 100;
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        const toHex = x => {
          const hex = Math.round(x * 255).toString(16);
          return hex.length === 1 ? "0" + hex : hex;
        };
        return "#" + toHex(r) + toHex(g) + toHex(b);
      }

      function jitterHex(hex, deltaH = 8, deltaL = 6) {
        const { h, s, l } = hexToHsl(hex);
        const nh = (h + (Math.random() * 2 - 1) * deltaH + 360) % 360;
        const nl = Math.min(90, Math.max(10, l + (Math.random() * 2 - 1) * deltaL));
        return hslToHex(nh, s, nl);
      }

      function drawLeaf(inner, outer, layers) {
        const PAL = getPalette();
        const middle = (inner + outer) / 2;
        const half   = (outer - inner) / 2;
        const H      = half * 0.7;

        ctx.save();
        ctx.translate(middle, 0);

        for (let j = 0; j < layers; j++) {
          const t = j / (layers - 1 || 1);
          const w = half * (1 - t * 0.55);
          const h = H    * (1 - t * 0.85);

          ctx.beginPath();
          ctx.moveTo(-w, 0);
          ctx.quadraticCurveTo(0, -h, w, 0);
          ctx.quadraticCurveTo(0,  h, -w, 0);

          ctx.fillStyle = PAL[(j + 1) % PAL.length];
          ctx.fill();

          ctx.strokeStyle = COLORS.line;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawLeaves(scale) {
        const count = CONFIG.leafCount;
        const start = CONFIG.leafStart * scale;
        const outer = 190 * scale;

        ctx.save();
        const step = Math.PI * 2 / count;
        for (let i = 0; i < count; i++) {
          ctx.rotate(step);
          drawLeaf(start, outer, 4);
        }
        ctx.restore();
      }

      function drawOuterRing(scale) {
        const count = CONFIG.leafCount;
        const step = Math.PI * 2 / count;

        ctx.save();

        ctx.beginPath();
        ctx.arc(0, 0, 200 * scale, 0, Math.PI * 2);
        ctx.strokeStyle = COLORS.line;
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = COLORS.sub;

        const arcs = [
          [210, 0, 20, -10, 120],
          [220, 20, 20, 180, 300],
          [180, 60, 10, 250, 30],
          [186, 55, 10, 70, 230]
        ];

        for (let i = 0; i < count; i++) {
          ctx.rotate(step);
          arcs.forEach(([x, y, r, s, e]) => {
            ctx.beginPath();
            ctx.arc(x * scale, y * scale, r * scale, s * Math.PI / 180, e * Math.PI / 180);
            ctx.fill();
            ctx.strokeStyle = COLORS.line;
            ctx.stroke();
          });
        }

        ctx.restore();
      }

      function drawCenterFlower(scale) {
        const leafNum = CONFIG.leafCount;
        const PAL = getPalette();

        const C = Math.max(4, Math.round(leafNum / 4));
        const TOTAL = Math.max(8, Math.round(leafNum / 2));
        const localS = 0.45 + (Math.min(leafNum, 64) / 64) * 0.25;

        ctx.save();
        ctx.scale(scale * localS, scale * localS);

        ctx.strokeStyle = COLORS.line;
        ctx.lineWidth = 1 / (scale * localS);

        for (let i = 0; i < C; i++) {
          ctx.save();
          ctx.rotate((Math.PI * 2 / C) * i);

          ctx.beginPath();
          ctx.arc(10, 0, 10, 0, Math.PI * 2);
          ctx.fillStyle = PAL[i % PAL.length];
          ctx.fill();
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(24, 0, 12, 0, Math.PI * 2);
          ctx.fillStyle = PAL[(i + 1) % PAL.length];
          ctx.fill();
          ctx.stroke();

          ctx.restore();
        }

        for (let i = 0; i < TOTAL; i++) {
          ctx.save();
          ctx.rotate((Math.PI * 2 / TOTAL) * i);

          if (i % 2 === 0) {
            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.quadraticCurveTo(50, 30, 60, 60);
            ctx.quadraticCurveTo(30, 50, 30, 30);
            ctx.fillStyle = COLORS.main;
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.quadraticCurveTo(70, 30, 120, 120);
            ctx.quadraticCurveTo(30, 70, 30, 30);
            ctx.fillStyle = COLORS.sub;
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.moveTo(150, 0);
            ctx.quadraticCurveTo(175, -40, 200, 0);
            ctx.quadraticCurveTo(175, 40, 150, 0);
            ctx.fillStyle = COLORS.accent;
            ctx.fill();
            ctx.stroke();
          }

          ctx.restore();
        }

        ctx.restore();
      }

      function drawBug2(scale) {
        const s = 0.18 * scale;
        ctx.fillStyle = COLORS.main;
        ctx.strokeStyle = COLORS.line;
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-130 * s, -170 * s, -190 * s, -90 * s, -110 * s, 0);
        ctx.bezierCurveTo(-190 * s, 90 * s, -130 * s, 170 * s, 0, 100 * s);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(130 * s, -170 * s, 190 * s, -90 * s, 110 * s, 0);
        ctx.bezierCurveTo(190 * s, 90 * s, 130 * s, 170 * s, 0, 100 * s);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -90 * s);
        ctx.lineTo(0, 180 * s);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -90 * s);
        ctx.bezierCurveTo(-30 * s, -140 * s, -50 * s, -180 * s, -40 * s, -200 * s);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -90 * s);
        ctx.bezierCurveTo(30 * s, -140 * s, 50 * s, -180 * s, 40 * s, -200 * s);
        ctx.stroke();
      }

      function drawBugsRing(scale) {
        const count = CONFIG.bugCount;
        const step = Math.PI * 2 / count;
        const radius = CONFIG.leafStart * scale + 40 * scale;

        ctx.save();

        for (let i = 0; i < count; i++) {
          ctx.save();
          ctx.rotate(step * i + step / 2);
          ctx.translate(radius, 0);
          ctx.rotate(Math.PI / 2);
          drawBug2(scale);
          ctx.restore();
        }
        ctx.restore();
      }

      function drawTopRedPetals(scale) {
        const count = CONFIG.leafCount;
        const step = Math.PI * 2 / count;

        ctx.save();

        for (let i = 0; i < count; i++) {
          ctx.save();
          ctx.rotate(step * i);

          ctx.beginPath();
          ctx.moveTo(0, 90 * scale);
          ctx.quadraticCurveTo(10 * scale, 70 * scale, 0, 50 * scale);
          ctx.quadraticCurveTo(-10 * scale, 70 * scale, 0, 90 * scale);
          ctx.fillStyle = COLORS.main;
          ctx.fill();
          ctx.stroke();

          ctx.restore();
        }

        ctx.restore();
      }

      function drawMandalaAt(cx, cy, s) {
        ctx.save();
        ctx.translate(cx, cy);

        drawOuterRing(s);
        drawLeaves(s);
        drawCenterFlower(s);
        drawBugsRing(s);
        drawTopRedPetals(s);

        ctx.restore();
      }

      function drawBackground() {
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);

        const baseScale = 1;
        const density = 2;
        const mandalaScale = baseScale * (1.1 - density * 0.15);

        const baseSpacing = 480;
        const spacingX = baseSpacing * mandalaScale;
        const spacingY = spacingX * 0.86;

        const startY = -spacingY;
        const endY   = rect.height + spacingY;

        for (let row = 0, y = startY; y < endY; row++, y += spacingY) {
          const rowOffsetX = (row % 2 === 1) ? spacingX / 2 : 0;
          const startX = -spacingX + rowOffsetX;
          const endX   = rect.width + spacingX;

          for (let x = startX; x < endX; x += spacingX) {
            drawMandalaAt(x, y, mandalaScale);
          }
        }
      }

      function resize() {
        const ratio = window.devicePixelRatio || 1;
        const w = window.innerWidth;
        const h = window.innerHeight;
        canvas.width  = w * ratio;
        canvas.height = h * ratio;
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        drawBackground();
      }

      window.addEventListener("resize", resize);
      resize();

      // 시작 블랙 → 페이드아웃
      const blackout = document.getElementById("blackout");
      if (blackout) {
        requestAnimationFrame(() => {
          blackout.classList.add("is-hidden");
        });
      }

      // 진입
      function goToApp() {
        if (blackout) {
          blackout.classList.remove("is-hidden");
          // 화면이 닫히는 애니메이션 후 이동
          setTimeout(() => {
            window.location.href = "app.html";
          }, 650);
        } else {
          window.location.href = "app.html";
        }
      }

      document.body.addEventListener("click", goToApp);
      document.body.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          goToApp();
        }
      });

      /* ========================
          애니메이션 레이어
      ======================== */
      class FlowerLayer {
        constructor(x, y, delay, scale, colorsOverride) {
          this.x = x;
          this.y = y;
          this.delay = delay;
          this.t = 0;
          this.scale = scale;
          this.colors = colorsOverride;
        }
        update() {
          this.t += 0.01;
        }
        draw() {
          const offset = Math.sin(this.t + this.delay) * 5;
          const spin = Math.sin(this.t * 0.6 + this.delay) * 0.3 + this.t * 0.15;
          const prevColors = { ...COLORS };
          if (this.colors) {
            Object.assign(COLORS, this.colors);
          }
          ctx.save();
          ctx.translate(this.x, this.y + offset);
          ctx.rotate(spin);
          drawMandalaAt(0, 0, this.scale);
          ctx.restore();
          Object.assign(COLORS, prevColors);
        }
      }

      let layers = [];
      let mandalaScale = 1;

      function rebuildLayers() {
        layers = [];
        const density = 2;
        mandalaScale = 1 * (1.1 - density * 0.15);
        const baseSpacing = 480;
        const spacingX = baseSpacing * mandalaScale;
        const spacingY = spacingX * 0.86;
        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);
        const startY = -spacingY;
        const endY = h + spacingY;

        for (let row = 0, y = startY; y < endY; row++, y += spacingY) {
          const rowOffsetX = (row % 2 === 1) ? spacingX / 2 : 0;
          const startX = -spacingX + rowOffsetX;
          const endX   = w + spacingX;
          for (let x = startX; x < endX; x += spacingX) {
            const basePalette = PALETTES[Math.floor(Math.random() * PALETTES.length)];
            const palette = {
              line: jitterHex(basePalette.line, 4, 4),
              main: jitterHex(basePalette.main, 8, 6),
              accent: jitterHex(basePalette.accent, 10, 6),
              sub: jitterHex(basePalette.sub, 6, 6),
              light: jitterHex(basePalette.light, 4, 4)
            };
            layers.push(new FlowerLayer(x, y, Math.random() * Math.PI * 2, mandalaScale, palette));
          }
        }
      }

      function animate() {
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
        layers.forEach(layer => {
          layer.update();
          layer.draw();
        });
        requestAnimationFrame(animate);
      }

      // init animation layers once canvas is sized
      const originalResize = resize;
      function resizeWithLayers() {
        originalResize();
        rebuildLayers();
      }
      window.removeEventListener("resize", resize);
      window.addEventListener("resize", resizeWithLayers);
      resizeWithLayers();
      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>
